<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Hover Image Distortion Effect</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      overscroll-behavior: none;
      background-color: #ffffff;
      font-family: sans-serif;
    }

    .project-items {
      width: 100%;
      display: flex;
      gap: 2.5vw;
      align-items: flex-start;
      height: auto;
      margin-top: 60px;
    }

    .project-item {
      width: 100%;
      position: relative;
    }
    
    .project-item .img-box {
      aspect-ratio: 5 / 3;
    }

    .distort-container {
      position: relative;
      overflow: hidden;
      width: 100%;
      border-radius: 16px;
    }

    .distort-canvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    .content h2 {
      font-size: 16px;
      font-weight: 500;
      line-height: normal;
      text-transform: capitalize;
      transform: translateX(-39px);
      color: var(--text-color-1);
    }

    .project-title .hidden-arrow {
      color: var(--first-color);
      font-size: 20px;
      transform: scale(0);
      margin-right: 16px;
    }

    .content p {
      font-size: 14px;
      color: var(--text-color-3);
    }
    
    .hidden-arrow {
      color: var(--text-color-1) !important;
    }
    
    .project-item:hover .hidden-arrow {
      transform: scale(1);
      transition: all 0.4s ease-in-out;
    }
    .project-item:hover h2 {
      transform: translateX(-6px);
      transition: all 0.5s ease-in-out 0.1s;
    }
  </style>
</head>
<body>
  <div class="project-items">
      <div class="project-item">
          <a href="./dashboard.html">
              <div class="distort-container img-box">
                  <canvas class="distort-canvas" data-src="./img/index/content/1.png"></canvas>
              </div>
              <div class="project-title">
                  <svg class="icon hidden-arrow" aria-hidden="true">
                      <use xlink:href="#icon-arrow"></use>
                  </svg>           
                  <h2>[ moble design ] 移动端</h2>
              </div>
          </a>
      </div>

      <div class="project-item">
          <a href="./visualization.html">
              <div class="distort-container img-box">                           
                  <canvas class="distort-canvas" data-src="https://framerusercontent.com/images/a5yPNhznhsxSJvjwQPmQU1gxII.png?scale-down-to=512"></canvas>
              </div>
              <div class="project-title">
                  <svg class="icon hidden-arrow" aria-hidden="true">
                      <use xlink:href="#icon-arrow"></use>
                  </svg>           
                  <h2>[ visualization ] 可视化</h2>
              </div>
          </a>
      </div>
      
      <div class="project-item">
          <a href="./visualization.html">
              <div class="distort-container img-box">                           
                  <canvas class="distort-canvas" data-src="https://framerusercontent.com/images/k81gdfMzOziK19JNb4dUQoQFQ4Q.png?scale-down-to=512"></canvas>
              </div>
              <div class="project-title">
                  <svg class="icon hidden-arrow" aria-hidden="true">
                      <use xlink:href="#icon-arrow"></use>
                  </svg>           
                  <h2>[ visualization ] 可视化</h2>
              </div>
          </a>
      </div>
  </div>

  <script>
    class DistortionEffect {
      constructor() {
        // 可调节参数区域 ============================================
        this.distortionRadius = 150; // 扭曲半径(像素)
        this.distortionStrength = 0.3; // 扭曲强度(0-1)
        this.rgbSplitAmount = 8; // RGB分离程度(像素)
        this.animationSpeed = 0.05; // 动画速度(0-1)
        // ========================================================
        
        this.canvases = [...document.querySelectorAll('.distort-canvas')];
        this.activeCanvas = null;
        this.mouse = { x: 0, y: 0 };
        this.animationFrame = null;
        
        this.init();
      }
      
      init() {
        // 初始化所有canvas
        this.canvases.forEach((canvas, index) => {
          canvas.id = `canvas-${index}`;
          const container = canvas.parentElement;
          const imgSrc = canvas.dataset.src;
          
          // 设置canvas尺寸
          const resizeCanvas = () => {
            const { width, height } = container.getBoundingClientRect();
            canvas.width = width;
            canvas.height = height;
          };
          
          // 加载图像
          const img = new Image();
          img.crossOrigin = "anonymous";
          img.src = imgSrc;
          
          img.onload = () => {
            resizeCanvas();
            this.drawOriginalImage(canvas, img);
            
            // 保存原始图像数据
            canvas.originalImage = img;
            canvas.ctx = canvas.getContext('2d');
            canvas.originalImageData = canvas.ctx.getImageData(0, 0, canvas.width, canvas.height);
          };
          
          // 窗口大小变化时重绘
          window.addEventListener('resize', () => {
            resizeCanvas();
            if (canvas.originalImage) {
              this.drawOriginalImage(canvas, canvas.originalImage);
            }
          });
          
          // 鼠标进入事件
          container.addEventListener('mouseenter', () => {
            this.activeCanvas = canvas;
            if (!this.animationFrame) {
              this.animate();
            }
          });
          
          // 鼠标移动事件
          container.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            this.mouse = {
              x: e.clientX - rect.left,
              y: e.clientY - rect.top
            };
          });
          
          // 鼠标离开事件
          container.addEventListener('mouseleave', () => {
            if (this.activeCanvas === canvas) {
              this.activeCanvas = null;
              // 恢复原始图像
              if (canvas.originalImageData) {
                canvas.ctx.putImageData(canvas.originalImageData, 0, 0);
              }
            }
          });
        });
      }
      
      drawOriginalImage(canvas, img) {
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
        // 保存原始图像数据
        canvas.originalImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      }
      
      applyDistortion(canvas, mouseX, mouseY) {
        const ctx = canvas.getContext('2d');
        const { width, height } = canvas;
        const originalData = canvas.originalImageData;
        const distortedData = ctx.createImageData(width, height);
        
        const radius = this.distortionRadius;
        const strength = this.distortionStrength * 30;
        const rgbSplit = this.rgbSplitAmount;
        
        // 遍历所有像素
        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            // 计算与鼠标的距离
            const dx = x - mouseX;
            const dy = y - mouseY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // 如果在扭曲半径内
            if (distance < radius) {
              // 计算扭曲强度(距离越近强度越大)
              const intensity = 1 - distance / radius;
              const waveIntensity = strength * intensity * intensity;
              
              // 计算波浪偏移
              const angle = Math.atan2(dy, dx);
              const waveX = Math.sin(angle * 5 + Date.now() * 0.005) * waveIntensity;
              const waveY = Math.cos(angle * 3 + Date.now() * 0.003) * waveIntensity * 0.5;
              
              // 计算新位置
              const newX = Math.min(width - 1, Math.max(0, x + waveX));
              const newY = Math.min(height - 1, Math.max(0, y + waveY));
              
              // 获取原始像素数据
              const origPos = (y * width + x) * 4;
              const newPos = (Math.floor(newY) * width + Math.floor(newX)) * 4;
              
              // 应用RGB分离效果
              distortedData.data[origPos] = originalData.data[newPos]; // R
              distortedData.data[origPos + 1] = originalData.data[newPos + 1 + (y % 2 === 0 ? rgbSplit : -rgbSplit)]; // G
              distortedData.data[origPos + 2] = originalData.data[newPos + 2 + (x % 2 === 0 ? -rgbSplit : rgbSplit)]; // B
              distortedData.data[origPos + 3] = 255; // Alpha
            } else {
              // 扭曲半径外的区域保持原样
              const pos = (y * width + x) * 4;
              distortedData.data[pos] = originalData.data[pos];
              distortedData.data[pos + 1] = originalData.data[pos + 1];
              distortedData.data[pos + 2] = originalData.data[pos + 2];
              distortedData.data[pos + 3] = originalData.data[pos + 3];
            }
          }
        }
        
        ctx.putImageData(distortedData, 0, 0);
      }
      
      animate() {
        if (this.activeCanvas && this.activeCanvas.originalImageData) {
          this.applyDistortion(this.activeCanvas, this.mouse.x, this.mouse.y);
          this.animationFrame = requestAnimationFrame(() => this.animate());
        } else {
          this.animationFrame = null;
        }
      }
    }
    
    // 初始化
    window.addEventListener('load', () => {
      new DistortionEffect();
    });
  </script>
</body>
</html>